<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>최신 주소 연결기 (TVMon / 짭플릭스)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- 캐시 방지 -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">

  <script>
    // HTML을 항상 새로 받도록 1회성 캐시버스터
    (function () {
      if (!/[?&]v=/.test(location.search)) {
        var ts = Date.now();
        var path = location.pathname.replace(/\/+$/, "/index.html");
        var search = location.search ? (location.search + "&v=" + ts) : ("?v=" + ts);
        location.replace(path + search + location.hash);
      }
    })();
  </script>

  <style>
    body {font-family: system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Malgun Gothic,sans-serif; line-height:1.6; padding:2rem; max-width:820px; margin:auto;}
    h1 {font-size:1.4rem; margin-bottom:1rem}
    .card {border:1px solid #e5e7eb; border-radius:12px; padding:1rem 1.25rem; box-shadow:0 1px 2px rgba(0,0,0,.04); background:#fff}
    .row {display:flex; gap:.75rem; flex-wrap:wrap; align-items:center}
    .small {color:#6b7280; font-size:.9rem}
    code {background:#f3f4f6; padding:.1rem .35rem; border-radius:6px}
    a.btn, button.btn {
      display:inline-flex; align-items:center; gap:.5rem;
      padding:.6rem 1rem; border:1px solid #d1d5db;
      border-radius:10px; text-decoration:none; background:#fff; cursor:pointer;
    }
    button.btn {font:inherit;}
    fieldset {border:0; padding:0; margin:0 0 .5rem}
    label.radio {display:inline-flex; align-items:center; gap:.4rem; padding:.25rem .5rem; border-radius:8px; border:1px solid #e5e7eb}
    .status {margin-top:.5rem}
    .muted {opacity:.6}
  </style>
</head>
<body>
  <h1>최신 주소 자동 연결기</h1>
  <div class="card">
    <p>서비스를 선택하고 <strong>최신 주소로 이동</strong>을 누르면, 소스 페이지에서 최신 도메인을 확인해 자동 이동합니다.</p>

    <fieldset>
      <legend class="small">서비스 선택</legend>
      <div class="row">
        <label class="radio"><input type="radio" name="svc" value="tvmon" checked> TVMon</label>
        <label class="radio"><input type="radio" name="svc" value="jjapflix"> 짭플릭스</label>
      </div>
    </fieldset>

    <div class="row" style="margin:.5rem 0 1rem">
      <button id="go" class="btn" type="button">최신 주소로 이동</button>
      <button id="stop" class="btn" type="button">연결 중지</button>
      <a id="fallback" class="btn" href="https://linkchak.com/index.html" rel="noopener" target="_blank">수동 확인 (링크착)</a>
    </div>

    <p class="small" id="status">상태: 대기 중…</p>
    <p class="small muted">팁: 자동 확인이 실패하면 <strong>수동 확인</strong> 버튼으로 소스 페이지를 직접 여세요.</p>
  </div>

  <script>
    // ---------- 공통 유틸 ----------
    const q = (sel) => document.querySelector(sel);
    const statusEl = q("#status");
    const fallbackEl = q("#fallback");
    const goBtn = q("#go");
    const stopBtn = q("#stop");

    let stopped = false;
    stopBtn.addEventListener("click", () => {
      stopped = true;
      statusEl.textContent = "상태: 연결 시도를 중지했습니다.";
    });

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const timeout = (ms) => new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), ms));

    // 각 URL을 우회 프록시 포함 후보군으로 확장
    const withProxies = (url) => {
      const noProto = url.replace(/^https?:\/\//, '');
      return [
        url,
        `https://r.jina.ai/http/${noProto}`,
        `https://r.jina.ai/${url}`,
        `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`
      ];
    };

    async function fetchTextWithFallback(url, ms = 6000) {
      const candidates = withProxies(url);
      for (const u of candidates) {
        if (stopped) throw new Error("stopped");
        try {
          statusEl.textContent = `상태: 소스 확인 중 (${u})…`;
          const res = await Promise.race([fetch(u, { credentials: "omit" }), timeout(ms)]);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const txt = await res.text();
          if (txt && txt.length) return txt;
        } catch (_) {
          // continue
        }
      }
      throw new Error("all candidates failed");
    }

    // ---------- 추출 로직 ----------
    // TVMon: tvmonNNN.org 중 가장 큰 숫자 선택
    function extractTVMon(html) {
      const set = new Map();
      const re1 = /https?:\/\/(?:www\.)?(tvmon(\d+)\.org)\b/gi;
      const re2 = /\b(tvmon(\d+)\.org)\b/gi;
      let m;
      while ((m = re1.exec(html)) !== null) set.set(m[1].toLowerCase(), Number(m[2]));
      while ((m = re2.exec(html)) !== null) set.set(m[1].toLowerCase(), Number(m[2]));
      if (set.size === 0) return null;
      return [...set.entries()].sort((a,b) => b[1] - a[1])[0][0]; // 도메인(키) 반환
    }

    // 짭플릭스: linkchak 페이지에서 앵커 텍스트/링크에 '짭플릭스' 키워드 포함 링크를 우선.
    // 없으면, 숫자 버전 패턴이 있는 링크들 중 가장 최신(숫자 큰 값) 추정.
    function extractJjapflixFromLinkchak(html) {
      // 앵커 href 추출
      const anchors = [];
      // 1) DOMParser가 cross-origin에서 제한될 수 있으므로 정규식 병행
      try {
        const doc = new DOMParser().parseFromString(html, 'text/html');
        doc.querySelectorAll('a[href]').forEach(a => {
          anchors.push({ href: a.getAttribute('href'), text: a.textContent.trim() });
        });
      } catch (_) {
        // fallback: 단순 정규식
        const re = /<a [^>]*href=["']([^"']+)["'][^>]*>(.*?)<\/a>/gis;
        let m; 
        while ((m = re.exec(html)) !== null) {
          anchors.push({ href: m[1], text: m[2].replace(/<[^>]+>/g,'').trim() });
        }
      }

      // 2) 키워드 우선 매칭
      const kw = ['짭플릭스', '짭 플릭스', '짭플', 'Jjapflix', 'jjapflix'];
      const byKeyword = anchors.find(a => {
        const blob = (a.href + ' ' + a.text).toLowerCase();
        return kw.some(k => blob.includes(k.toLowerCase()));
      });
      if (byKeyword && byKeyword.href) {
        return absolutize(byKeyword.href);
      }

      // 3) 숫자 버전 휴리스틱 (예: example123.com, zflix45.com 등)
      const scored = anchors.map(a => {
        const url = absolutize(a.href);
        const m = /(\d{1,4})\D*(?:\.\w{2,})?$/.exec(url.replace(/^https?:\/\//,'').split('/')[0]); // 호스트에서 끝부분 숫자
        return { url, score: m ? parseInt(m[1], 10) : -1 };
      }).filter(x => !!x.url);

      if (scored.length) {
        scored.sort((a,b) => b.score - a.score);
        if (scored[0].score >= 0) return scored[0].url;
      }

      // 4) 마지막 fallback: 첫 번째 외부 링크
      const firstExternal = anchors.find(a => /^https?:\/\//i.test(a.href));
      return firstExternal ? absolutize(firstExternal.href) : null;

      function absolutize(href) {
        try {
          return new URL(href, "https://linkchak.com/index.html").href;
        } catch { return href; }
      }
    }

    // ---------- 서비스 핸들러 ----------
    async function resolveLatestURL(service) {
      if (service === 'tvmon') {
        // 여러 출처를 순회하며 최신 도메인 추출
        const sources = [
          "https://tvmonnewaddress.com/",
          "https://www.tvmonnewaddress.com/",
          "https://linkchak.com/index.html" // 보조: 링크착에도 있을 수 있으니 검사
        ];
        for (const src of sources) {
          if (stopped) throw new Error("stopped");
          try {
            const html = await fetchTextWithFallback(src);
            const domain = extractTVMon(html);
            if (domain) return `https://${domain}`;
          } catch (_) {/* 다음 소스 시도 */}
        }
        return null;
      }

      if (service === 'jjapflix') {
        // 짭플릭스는 링크착에서 추출
        const LINKCHAK = "https://linkchak.com/index.html";
        try {
          const html = await fetchTextWithFallback(LINKCHAK);
          const url = extractJjapflixFromLinkchak(html);
          return url || null;
        } catch (_) {
          return null;
        }
      }

      return null;
    }

    // ---------- UI 동작 ----------
    goBtn.addEventListener("click", async () => {
      stopped = false;
      statusEl.textContent = "상태: 최신 주소 확인을 시작합니다…";

      const svc = (document.querySelector('input[name="svc"]:checked')?.value) || 'tvmon';

      // fallback 링크를 서비스에 맞게 갱신
      if (svc === 'tvmon') {
        fallbackEl.href = "https://tvmonnewaddress.com/";
      } else {
        fallbackEl.href = "https://linkchak.com/index.html";
      }

      try {
        const url = await resolveLatestURL(svc);
        if (stopped) return; // 중지됨

        if (url) {
          statusEl.textContent = `상태: 최신 주소 찾음 → ${url} 로 이동합니다.`;
          await sleep(300);
          location.replace(url);
        } else {
          statusEl.innerHTML = `자동 확인에 실패했습니다. <strong>수동 확인</strong> 버튼으로 소스에서 직접 확인해 주세요.`;
          fallbackEl.focus();
        }
      } catch (e) {
        if (e && e.message === 'stopped') return;
        statusEl.textContent = `상태: 오류가 발생했습니다. 수동 확인을 이용해 주세요.`;
      }
    });
  </script>
</body>
</html>
